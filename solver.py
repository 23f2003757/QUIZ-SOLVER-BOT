import asyncio
import logging
import json
import os
import subprocess
import sys
from playwright.async_api import async_playwright
from agent import QuizAgent
import requests
from urllib.parse import urljoin

logger = logging.getLogger(__name__)

class QuizSolver:
    def __init__(self):
        self.agent = QuizAgent()

    async def solve(self, email: str, secret: str, start_url: str):
        current_url = start_url
        
        async with async_playwright() as p:
            browser = await p.chromium.launch(headless=True)
            context = await browser.new_context()
            page = await context.new_page()
            
            while current_url:
                logger.info(f"Navigating to {current_url}")
                try:
                    await page.goto(current_url, timeout=60000)
                    await page.wait_for_load_state("networkidle")
                except Exception as e:
                    logger.error(f"Failed to load page {current_url}: {e}")
                    break

                # Extract content
                # We assume the question is visible on the page. 
                # The example shows <div id="result">...</div> which might contain the question.
                # Or it might be just text on the page.
                # Let's get the full body text and specific elements.
                
                # Check for the specific structure mentioned in the prompt (decoding base64 in #result)
                # But the prompt says "Render it on your browser and youâ€™ll see this sample question"
                # So we can just get the innerText of the body or main container.
                
                content = await page.content()
                body_text = await page.inner_text("body")
                
                logger.info(f"Page content extracted. Length: {len(body_text)}")
                
                # Ask Agent to solve
                # We pass the body text as the question context
                plan = self.agent.analyze_task(body_text, content)
                
                logger.info(f"Agent plan: {plan.get('thought')}")
                code = plan.get("code")
                
                if not code:
                    logger.error("Agent failed to generate code.")
                    break
                
                # Execute Code
                # WARNING: Executing arbitrary code is dangerous.
                # For this contest, we assume it's "safe" enough or running in a disposable env.
                logger.info("Executing code...")
                output = self.execute_code(code)
                logger.info(f"Code output: {output}")
                
                # Extract final answer
                answer = self.agent.extract_answer(output, body_text)
                logger.info(f"Extracted answer: {answer}")
                
                # Submit
                # We need to find the submit URL. The agent should have identified it or we parse it.
                # Actually, the prompt says "The quiz page always includes the submit URL to use."
                # We can ask the agent to extract the submit URL and payload structure too, 
                # OR we can try to find it ourselves.
                # Let's ask the agent to return the submission details in the plan or a separate step.
                # For now, let's assume the code execution might handle submission OR we do it here.
                # The prompt says: "Post your answer to ... with this JSON payload".
                # It's better if the Python code generated by the agent PREPARES the answer, 
                # and we handle the submission to ensure we use the correct email/secret.
                
                # Let's refine the Agent's task: "Return the answer AND the submit URL".
                # But `extract_answer` just gets the value.
                
                # Let's do a quick regex or LLM call to get the submit URL from the text if possible.
                # Or better, let the generated code print the answer, and we construct the payload.
                
                # We need the submit URL.
                submit_url = self.extract_submit_url(body_text)
                if not submit_url:
                    # Fallback: ask LLM to find it
                    submit_url = self.agent.extract_submit_url_from_text(body_text)
                
                if submit_url:
                    submit_url = urljoin(current_url, submit_url)
                
                if not submit_url:
                    logger.error("Could not find submit URL")
                    break

                payload = {
                    "email": email,
                    "secret": secret,
                    "url": current_url,
                    "answer": answer
                }
                
                logger.info(f"Submitting to {submit_url} with payload: {payload}")
                
                try:
                    response = requests.post(submit_url, json=payload, timeout=30)
                    res_json = response.json()
                    logger.info(f"Submission result: {res_json}")
                    
                    if res_json.get("correct"):
                        next_url = res_json.get("url")
                        if next_url:
                            current_url = next_url
                            logger.info(f"Moving to next URL: {next_url}")
                        else:
                            logger.info("Quiz completed!")
                            current_url = None
                    else:
                        logger.warning(f"Wrong answer: {res_json.get('reason')}")
                        # Retry logic could go here, but for now we stop or retry?
                        # The prompt says we can re-submit within 3 mins.
                        # For now, let's stop to avoid infinite loops in this basic version.
                        break
                        
                except Exception as e:
                    logger.error(f"Submission failed: {e}")
                    break

            await browser.close()

    def execute_code(self, code: str) -> str:
        # Save code to a file
        with open("temp_solver.py", "w", encoding="utf-8") as f:
            f.write(code)
        
        try:
            result = subprocess.run(
                [sys.executable, "temp_solver.py"],
                capture_output=True,
                text=True,
                timeout=60
            )
            return result.stdout + "\n" + result.stderr
        except Exception as e:
            return str(e)

    def extract_submit_url(self, text: str) -> str:
        # Simple heuristic or regex
        # "Post your answer to https://..."
        import re
        match = re.search(r"Post your answer to (https?://[^\s]+)", text)
        if match:
            return match.group(1).rstrip('.')
        return None


